/**
 * This class definition is very minimal. It only provides the methods
 * which are necessary for its relation with the Base class.
 * Most of the functionality is autogenerated - see the VehBus class example.
 */

#pragma once

#include "base.h"
#include "msg.h"

namespace can {

class Bus {
public:
    Bus(Base& can_base);

    /**
     * Send a message.
     */
    template <TxMessage T>
    void Send(T msg);

private:
    Base& can_base_;

    /**
     * Given a RawMessage, decode it based on its ID and store in this
     * bus.
     */
    virtual void AddMessage(const RawMessage& msg, uint32_t timestamp) = 0;
    friend class Base;
};

/**
 * @brief Relay the message to the base.
 * @note This is a template method so it must be defined in the header.
 */
template <TxMessage T>
void Bus::Send(T msg) {
    can_base_.Send(msg.encode());
}

}  // namespace can