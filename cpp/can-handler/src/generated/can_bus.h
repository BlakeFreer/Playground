/**
 * @brief This file would be autogenerated by cangen
 */

#include "can_msgs.h"
#include "canlib/base.h"
#include "canlib/bus.h"
#include "canlib/msg.h"

namespace can {

class VehBus : public Bus {
public:
    VehBus(Base& can_base) : Bus(can_base) {}

    /**
     * @brief Get the Latest message of any type. Uses templates to make it
     * really easy to call.
     * @example `auto msg = bus.GetLatest<PackStateMsg>();`
     * Notice it returns an optional, not necessarily a message.
     */
    template <typename T>
    std::optional<T> GetLatest() const;

    /**
     * @brief Like GetLatest but removes the message from the bus.
     */
    template <typename T>
    std::optional<T> PopLatest();

private:
    void AddMessage(const RawMessage& msg, uint32_t timestamp) override {
        // This switch is faster than a map lookup. It is autogenerated so there
        // is not cost to writing it.
        // Filtering is cleanly handled by the `default` case - any message
        // which isn't part of this node will fall through the default.

        switch (msg.id) {
            case RxPackState::id():
                pack_state_msg = RxPackState::decode(msg, timestamp);
                break;
            case RxContactorState::id():
                contactor_state_msg = RxContactorState::decode(msg, timestamp);
                break;
            default:
                // ignore message -> not part of registry
                break;
        }
    }

    // All messages start empty. As soon as one arrives it will be filled.
    // We would could add PopLastest() to optionally get then remove the latest
    // message.
    std::optional<RxPackState> pack_state_msg = std::nullopt;
    std::optional<RxContactorState> contactor_state_msg = std::nullopt;

    friend class Base;
};

// Specialize the GetLatest template for each message type. We could also make
// individual getters like GetLatestPackStateMsg() and
// GetLatestContactorStateMsg() but I think the template is cleaner.

template <>
auto VehBus::GetLatest<RxPackState>() const -> std::optional<RxPackState> {
    return pack_state_msg;
}
template <>
auto VehBus::PopLatest<RxPackState>() -> std::optional<RxPackState> {
    auto temp = pack_state_msg;
    pack_state_msg = std::nullopt;
    return temp;
}

template <>
auto VehBus::GetLatest<RxContactorState>() const
    -> std::optional<RxContactorState> {
    return contactor_state_msg;
}
template <>
auto VehBus::PopLatest<RxContactorState>() -> std::optional<RxContactorState> {
    auto temp = contactor_state_msg;
    contactor_state_msg = std::nullopt;
    return temp;
}

}  // namespace can