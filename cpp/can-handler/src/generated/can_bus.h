/**
 * @brief This file would be autogenerated by cangen
 */

#include "can_msgs.h"
#include "canlib/base.h"
#include "canlib/bus.h"
#include "canlib/msg.h"

namespace can {

class VehBus : public Bus {
   public:
    VehBus(Base& can_base) : Bus(can_base) {}

    /**
     * @brief Get the Latest message of any type. Uses templates to make it
     * really easy to call.
     * @example `auto msg = bus.GetLatest<PackStateMsg>();`
     * Notice it returns an optional, not necessarily a message.
     */
    template <Message T>
    std::optional<std::tuple<T, uint32_t>> GetLatest() const;

    /**
     * @brief Like GetLatest but removes the message from the bus.
     */
    template <Message T>
    std::optional<std::tuple<T, uint32_t>> PopLatest();

   private:
    void AddMessage(const RawMessage& msg, uint32_t timestamp) override {
        // This switch is faster than a map lookup. It is autogenerated so there
        // is not cost to writing it.
        // Filtering is cleanly handled by the `default` case - any message
        // which isn't part of this node will fall through the default.
        switch (msg.id) {
            case PackStateMsg::id():
                pack_state_msg =
                    std::tuple(PackStateMsg::decode(msg), timestamp);
                break;
            case ContactorStateMsg::id():
                contactor_state_msg =
                    std::tuple(ContactorStateMsg::decode(msg), timestamp);
                break;
            default:
                // ignore message -> not part of registry
                break;
        }
    }

    // All messages start empty. As soon as one arrives it will be filled.
    // We would could add PopLastest() to optionally get then remove the latest
    // message.
    std::optional<std::tuple<PackStateMsg, uint32_t>> pack_state_msg =
        std::nullopt;
    std::optional<std::tuple<ContactorStateMsg, uint32_t>> contactor_state_msg =
        std::nullopt;

    friend class Base;
};

// Specialize the GetLatest template for each message type. We could also make
// individual getters like GetLatestPackStateMsg() and
// GetLatestContactorStateMsg() but I think the template is cleaner.
template <>
std::optional<std::tuple<PackStateMsg, uint32_t>>
VehBus::GetLatest<PackStateMsg>() const {
    return pack_state_msg;
}
template <>
std::optional<std::tuple<ContactorStateMsg, uint32_t>>
VehBus::GetLatest<ContactorStateMsg>() const {
    return contactor_state_msg;
}

template <>
std::optional<std::tuple<ContactorStateMsg, uint32_t>>
VehBus::PopLatest<ContactorStateMsg>() {
    auto temp = contactor_state_msg;
    contactor_state_msg = std::nullopt;
    return temp;
}
template <>
std::optional<std::tuple<PackStateMsg, uint32_t>>
VehBus::PopLatest<PackStateMsg>() {
    auto temp = pack_state_msg;
    pack_state_msg = std::nullopt;
    return temp;
}

}  // namespace can