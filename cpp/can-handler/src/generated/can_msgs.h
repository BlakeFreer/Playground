/**
 * @brief This file would be autogenerated by cangen
 */

#pragma once

#include <optional>

#include "canlib/msg.h"

namespace can {

class VehBus;

class RxPackState {
public:
    // use getters to prevent mutating the data which is guaranteed to come from
    // the CAN line.
    // clang-format off
    inline float PackCurrent() const { return pack_current_; }
    inline float PackInstVoltage() const { return pack_inst_voltage_; }
    inline float AvgCellVoltage() const { return avg_cell_voltage_; }
    inline uint8_t PopulatedCells() const { return populated_cells_; }
    inline uint32_t Timestamp() const { return timestamp_; }
    // clang-format on

private:
    float pack_current_;
    float pack_inst_voltage_;
    float avg_cell_voltage_;
    uint8_t populated_cells_;
    uint32_t timestamp_;

    // Private since the app shouldn't be using them.
    constexpr static uint32_t id() {
        return 0x100;
    }
    constexpr static uint8_t data_length() {
        return 7;
    }

    // this friend line is autogen, no issue with it being node specific
    friend class VehBus;

    // only VehBus can create this -> guarantees data came from the CAN line
    static RxPackState decode(const RawMessage& msg, uint32_t timestamp) {
        // using a static method instead of a constructor allows us to perform
        // logic then construct const fields.
        float pack_current_ = (float)msg.data[0];
        float pack_inst_voltage_ = (float)msg.data[1];
        float avg_cell_voltage_ = (float)msg.data[2];
        uint8_t populated_cells_ = msg.data[3];
        uint32_t timestamp_ = timestamp;
        return RxPackState(pack_current_, pack_inst_voltage_, avg_cell_voltage_,
                           populated_cells_, timestamp_);
    }

    RxPackState() = delete;
    RxPackState(float pack_current, float pack_inst_voltage,
                float avg_cell_voltage, uint8_t populated_cells,
                uint32_t timestamp)
        : pack_current_(pack_current),
          pack_inst_voltage_(pack_inst_voltage),
          avg_cell_voltage_(avg_cell_voltage),
          populated_cells_(populated_cells),
          timestamp_(timestamp) {}
};

class RxContactorState {
public:
    // clang-format off
    inline uint8_t PackPositive() const { return pack_positive; }
    inline uint8_t PackPrecharge() const { return pack_precharge; }
    inline uint8_t PackNegative() const { return pack_negative; }
    inline uint32_t Timestamp() const { return timestamp; }
    // clang-format on

private:
    uint8_t pack_positive;
    uint8_t pack_precharge;
    uint8_t pack_negative;
    uint32_t timestamp;

    // Private since the app shouldn't be using them.
    constexpr static uint32_t id() {
        return 0x200;
    }
    constexpr static uint8_t data_length() {
        return 3;
    }

    // this friend line is autogen, no issue with it being node specific
    friend class VehBus;

    // only VehBus can create this -> guarantees data came from the CAN line
    static RxContactorState decode(const RawMessage& msg, uint32_t timestamp) {
        // using a static method instead of a constructor allows us to perform
        // logic then construct const fields.
        uint8_t pack_positive_ = msg.data[0];
        uint8_t pack_precharge_ = msg.data[1];
        uint8_t pack_negative_ = msg.data[2];

        uint32_t timestamp_ = timestamp;
        return RxContactorState(pack_positive_, pack_precharge_, pack_negative_,
                                timestamp_);
    }

    RxContactorState() = delete;
    RxContactorState(uint8_t pack_positive_, uint8_t pack_precharge_,
                     uint8_t pack_negative_, uint32_t timestamp_)
        : pack_positive(pack_positive_),
          pack_precharge(pack_precharge_),
          pack_negative(pack_negative_),
          timestamp(timestamp_) {}
};

class TxContactorState {
public:
    static auto create(uint8_t pack_positive, uint8_t pack_precharge,
                       uint8_t pack_negative)
        -> std::optional<TxContactorState> {
        // Use a factory method to validate data before constructing
        // Lets us verify the data satisfies the DBC constraints.
        if (pack_positive > 1) return std::nullopt;
        if (pack_precharge > 1) return std::nullopt;
        if (pack_negative > 1) return std::nullopt;

        return TxContactorState(pack_positive, pack_precharge, pack_negative);
    }

    // I debated for a long time about making this a public method since it
    // creates a mutable RawMessage object. However, since only the VehBus can
    // decode the RawMessage into an Rx message, it is impossible for this
    // mutability to wind back up in the main.

    // This means that you "could" call .encode on a Tx message in main, but you
    // would have nothing to do with it.
    auto encode() const -> RawMessage {
        uint8_t data[3] = {pack_positive_, pack_precharge_, pack_negative_};
        return RawMessage::New(id(), data_length(), data);
    }

private:
    uint8_t pack_positive_;
    uint8_t pack_precharge_;
    uint8_t pack_negative_;

    // Private since the app shouldn't be using them.
    constexpr static uint32_t id() {
        return 0x200;
    }
    constexpr static uint8_t data_length() {
        return 3;
    }

    // Prevent creating an instance besides through the factory method.
    TxContactorState() = delete;
    TxContactorState(uint8_t pack_positive, uint8_t pack_precharge,
                     uint8_t pack_negative)
        : pack_positive_(pack_positive),
          pack_precharge_(pack_precharge),
          pack_negative_(pack_negative) {}

    friend class VehBus;
};

class TxPackState {
public:
    TxPackState() = delete;

    static auto create(float pack_current, float pack_inst_voltage,
                       float avg_cell_voltage, uint8_t populated_cells)
        -> std::optional<TxPackState> {
        // Use a factory method to validate data before constructing
        // Lets us verify the data satisfies the DBC constraints.
        if (pack_current < 0) return std::nullopt;
        if (pack_inst_voltage < 0) return std::nullopt;
        if (avg_cell_voltage < 0) return std::nullopt;

        return TxPackState(pack_current, pack_inst_voltage, avg_cell_voltage,
                           populated_cells);
    }
    auto encode() const -> RawMessage {
        // placeholder
        uint8_t data[7] = {0x01, 0xA2, 0xB3, 0xC4, 0xD5, 0xE6, 0xF7};
        return RawMessage::New(id(), data_length(), data);
    }

private:
    float pack_current_;
    float pack_inst_voltage_;
    float avg_cell_voltage_;
    uint8_t populated_cells_;
    // Private since the app shouldn't be using them.
    constexpr static uint32_t id() {
        return 0x100;
    }
    constexpr static uint8_t data_length() {
        return 7;
    }

    // Prevent creating an instance besides through the factory method.
    TxPackState(float pack_current, float pack_inst_voltage,
                float avg_cell_voltage, uint8_t populated_cells)
        : pack_current_(pack_current),
          pack_inst_voltage_(pack_inst_voltage),
          avg_cell_voltage_(avg_cell_voltage),
          populated_cells_(populated_cells) {}

    friend class VehBus;
};

}  // namespace can