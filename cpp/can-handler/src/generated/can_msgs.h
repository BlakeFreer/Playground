/**
 * @brief This file would be autogenerated by cangen
 * These messages satisfy the Message concept from canlib/msg.h
 * Each message knows how to encode and decode itself.
 */

#pragma once

#include "canlib/msg.h"

namespace can {

struct PackStateMsg {
    float pack_current;
    float pack_inst_voltage;
    float avg_cell_voltage;
    uint8_t populated_cells;

    static constexpr uint32_t id() {
        return 0x100;
    }
    static constexpr uint8_t data_length() {
        return 7;
    }

    RawMessage encode() const {
        // placeholder
        uint8_t data[7] = {0x01, 0xA2, 0xB3, 0xC4, 0xD5, 0xE6, 0xF7};
        return RawMessage::New(PackStateMsg::id(), PackStateMsg::data_length(),
                               data);
    };

    /**
     * Notice this is static so it does not have side effects on any instance.
     * This means it can safely be public since you can't do harm with it.
     */
    static PackStateMsg decode(const RawMessage& msg) {
        // placeholder
        return PackStateMsg{
            .pack_current = (float)msg.data[0],
            .pack_inst_voltage = (float)msg.data[1],
            .avg_cell_voltage = (float)msg.data[2],
            .populated_cells = msg.data[3],
        };
    }
};

struct ContactorStateMsg {
    uint8_t pack_positive;
    uint8_t pack_precharge;
    uint8_t pack_negative;

    static constexpr uint32_t id() {
        return 0x200;
    }

    static constexpr uint8_t data_length() {
        return 3;
    }

    RawMessage encode() const {
        // placeholder
        uint8_t data[3] = {pack_positive, pack_precharge, pack_negative};
        return RawMessage::New(ContactorStateMsg::id(),
                               ContactorStateMsg::data_length(), data);
    }

    static ContactorStateMsg decode(const RawMessage& msg) {
        // placeholder
        return ContactorStateMsg{
            .pack_positive = msg.data[0],
            .pack_precharge = msg.data[1],
            .pack_negative = msg.data[2],
        };
    }
};

}  // namespace can